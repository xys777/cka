# **1. 部署单控制平面集群**



[TOC]

## **1. 1 基础环境准备**

### **1.1.1 硬件准备**

机器配置：2核CPU，4G内存，40G系统盘

系统：Ubuntu 20.04

机器数量：3台 （master01	node01	node02）



### **1.1.2 系统环境配置**

修改配置静态hostname

```shell
hostnamectl set-hostname master01 --static
```



修改hosts表,集群所有节点保持文件内容一致

```shell
vim /etc/hosts
#Kubernetes
172.31.53.87    master01
172.31.53.88    node01
172.31.53.86    node02
```



配置服务器时间统一



关闭firewalld

```shell
ufw disable
```



关闭SELinux

```shell
ubuntu默认关闭SELinux
```



关闭swap

```shell
 # 临时关闭
 	swapoff -a

 # 永久关闭
 	注释掉/etc/fstab下的swap一行
```



 开启参数自动补全,取消bash-completion注释

```shell
vim /etc/bash.bashrc
# enable bash completion in interactive shells
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi
source /etc/bash.bashrc
```



### **1.1.3 Docker环境准备**

更新apt包索引

```shell
apt-get update
```



安装软件包以允许apt通过HTTPS使用存储库

```shell
apt-get -y install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
```



添加Docker的官方GPG密钥

```shell
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```



安装add-apt-repository工具

```shell
apt-get -y install software-properties-common
```



添加稳定的存储库

```shell
add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
```



更新apt包索引

```shell
apt-get update
```



查看Docker版本

```shell
apt-cache madison docker-ce
```

 

安装docker-ce最新版本

```shell
apt-get -y install docker-ce docker-ce-cli containerd.io
docker info
```

解决问题：WARNING: No swap limit support(操作系统下docker不支持内存限制的警告),基于RPM的系统上不会发生此警告，该系统默认情况下启用这些功能。解决方法：vim /etc/default/grub  添加或编辑GRUB_CMDLINE_LINUX行以添加这两个键值对"cgroup_enable=memory swapaccount=1"，例子：

```shell
GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1 net.ifnames=0 vga=792 console=tty0 console=ttyS0,115200n8 noibrs"
```

 执行命令更新grub并重启机器

```shell
update-grub && reboot
```



docker 在 1.13 版本之后，将系统iptables 中 FORWARD 链的默认策略设置为 DROP，并为连接到 docker0 网桥的容器添加了ACCEPT规则，临时解决办法：

```shell
iptables -P FORWARD ACCEPT
```

永久解决办法：

```shell
sed -i '/[[Service]]/a ExecStartPost=/sbin/iptables -P FORWARD ACCEPT' /lib/systemd/system/docker.service
```



设置daemon.json

```shell
cat > /etc/docker/daemon.json << EOF
{
    "oom-score-adjust": -1000,
    "exec-opts": ["native.cgroupdriver=systemd"],
    "log-driver": "json-file",
    "log-opts": {
       "max-size": "100m",
       "max-file": "3"
    },
    "max-concurrent-downloads": 10,
    "insecure-registries": ["0.0.0.0/0"],
    "max-concurrent-uploads": 10,
    "registry-mirrors": ["https://yefnfc9c.mirror.aliyuncs.com"],
    "storage-driver": "overlay2",
    "storage-opts": [
    "overlay2.override_kernel_check=true"
    ]
}
EOF
systemctl daemon-reload && systemctl restart docker.service
```

### **1.1.4 kubeadm环境准备**

配置apt库，安装kubeadm、kubelet、kubectl

```shell
apt-get update && apt-get install -y apt-transport-https
curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - 
cat <<EOF >/etc/apt/sources.list.d/kubernetes.list
deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
EOF
apt-get update
apt-cache madison kubeadm
1
```



开启这些设置使通过网桥的数据包由主机系统上的iptables规则处理，默认关闭，设置为1则开启

```shell
cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# sysctl params required by setup, params persist across reboots
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

# Apply sysctl params without reboot
sudo sysctl --system
```



## **1.2 创建单控制平面集群**

### **1.2.1 初始化集群**

命令详解

kubeadm config upload from-file：由配置文件上传到集群中生成ConfigMap；

kubeadm config upload from-flags：由配置参数生成ConfigMap；

kubeadm config view：查看当前集群中的配置值；

kubeadm config print init-defaults：输出kubeadm init默认参数文件的内容；

kubeadm config print join-defaults：输出kubeadm join默认参数文件的内容；

kubeadm config migrate：在新旧版本之间进行配置转换；

kubeadm config images list：列出所需的镜像列表；

kubeadm config images pull：拉取镜像到本地；



配置kubeadm的参数自动补全

```shell
# 查看completion帮助
kubeadm completion -h

# 配置自动补全
source <(kubeadm completion bash)
echo "source <(kubeadm completion bash)" >> ~/.bashrc
source ~/.bashrc 
```



生成配置文件

```shell
kubeadm config print init-defaults >  init-defaults.yaml
vim init-defaults.yaml修改：
	clusterName: Cluster01	
	name: master01
	advertiseAddress: 172.24.51.176
	imageRepository: registry.aliyuncs.com/google_containers
	  
# 在init-defaults文件的结尾添加以下内容，设置kubernetes的cgroupDriver为systemd
---
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
cgroupDriver: systemd
```

执行初始化操作

```shell
kubeadm init --config init-defaults.yaml
```

或者

```shell
kubeadm init --apiserver-advertise-address=172.24.205.51 --image-repository=registry.aliyuncs.com/google_containers
# 执行完初始化保存最后输出的结果到文件：管理用户配置、部署网络、添加节点相关信息.如果在初始化集群的时候出现报错，请执行   kubeadm reset  命令执行重置，解决提示的报错后在执行初始化操作。
```

### **1.2.2 kubectl配置文件**

root用户

```shell
echo "export KUBECONFIG=/etc/kubernetes/admin.conf" >> /root/.bashrc
source /root/.bashrc
```



非root用户

```shell
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```



### **1.2.3 kubectl参数自动补全**

查看completion帮助

```shell
kubectl completion -h
```



kubectl自动补全添加到当前shell

```shell
source <(kubectl completion bash)
echo "source <(kubectl completion bash)" >> ~/.bashrc
source ~/.bashrc 
```



### **1.2.4 Kubernetes网络**

```shell
kubectl apply -f https://docs.projectcalico.org/v3.23/manifests/calico.yaml

# 指定网卡名称
kubectl -n kube-system edit daemonsets.apps calico-node
spec:
  containers:
  - env:
    - name: IP_AUTODETECTION_METHOD  # 添加该环境变量
      value: interface=eth0    # 指定内网网卡名称，按事实情况修改
```



### **1.2.5 Nodes资源管理**

#### **1.2.5.1 添加Node节点**

```shell
# 创建token,并生成添加计算节点命令 （Master01节点执行）
 kubeadm token create --print-join-command
 ## 输出的添加节点的join命令，在计算节点执行

# 永久token
kubeadm token create --ttl 0

# 查看token （Master01节点执行）
kubeadm token list

# 获取discovery-token-ca-cert-hash值（Master01节点执行）
openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | \
   openssl dgst -sha256 -hex | sed 's/^.* //'

# 添加work节点到kubernetes集群（work node节点执行）
kubeadm join <api-server-ip:port> --token <toke> --discovery-token-ca-cert-hash sha256:<discovery-token-ca-cert-hash>  
```



```shell
kubeadm token create --print-join-command 
# 自动生成以下命令，直接加入节点
kubeadm join 172.21.184.81:6443 --token jde7q3.bv4ehxnyxfe04m56     --discovery-token-ca-cert-hash sha256:cde3bc85a4fbc5bdb0e78a532d0fa0fbc301485f7d86806c06ea59f6f9610032
```



#### **1.2.5.2 删除master节点**

```shell
# 删除/etc/kubernetes目录
rm -rf /etc/kubernetes/

# 删除etcd本机的存储目录
rm -rf /var/lib/etcd/

# ssh到<node_name>执行清理残留操作
kubeadm reset

# 删除残留目录
rm -rf /var/lib/etcd /var/lib/kubelet /var/lib/dockershim /var/run/kubernetes /var/lib/cni  /etc/cni/net.d

# 清理Iptables
iptables -F && iptables -t nat -F && iptables -t mangle -F && iptables -X

或者

# 清理IPVS
ipvsadm -C
```

#### **1.2.5.3 删除计算节点**

```shell
# 在master节点执行操作删除节点master
kubectl delete nodes <node_name>

------ 以下步骤在计算节点执行操作 ------
# 删除/etc/kubernetes目录
rm -rf /etc/kubernetes/

# ssh到<node_name>执行清理残留操作
kubeadm reset

# 删除残留目录
rm -rf /var/lib/kubelet /var/lib/dockershim /var/run/kubernetes /var/lib/cni  /etc/cni/net.d

# 清理Iptables
iptables -F && iptables -t nat -F && iptables -t mangle -F && iptables -X

或者

# 清理IPVS
ipvsadm -C
```

## **1.3 验证**

```shell
# 查看集群节点状态
kubectl get nodes

# 检查组件状态是否正常
kubectl get componentstatuses   

# 查看集群系统信息
kubectl cluster-info

# 查看核心组件是否运行正常（Running）
kubectl -n kube-system get pod

# 每次重启之后，删除非Up状态的容器
docker ps -a | grep -v Up | xargs docker rm -f
```

​       

