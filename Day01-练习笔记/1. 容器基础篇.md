# **1. 容器基础篇**



[TOC]

## **1. 1 容器概述**

### **1.1.1 容器的发展史**

物理服务器  ----> 虚拟化 ----> 容器

物理服务器：

​	优点：CPU性能和IO性能高，计算能力高；

​	缺点：管理维护麻烦，在很多应用场景会造成物理服务器的资源浪费；

虚拟化：

​	优点：虚拟化实现资源隔离的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等提高了物理服务器的资源利用。和物理服务器相比虚拟机的扩容、维护等会更简单；

​	缺点：因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的，会导致计算能力下降；

容器：

​	优点：容器并没有和虚拟机一样通过创建完全独立的操作系统实现环境隔离，它是通过Linux的namespace实现系统环境的隔离、Cgroup实现资源限制、利用镜像实现根目录环境的隔离。这种方式的隔离让容器具备了以下优势：1、占用磁盘空间小；2、启动速度快，以秒计时；3、并发性好，一台宿主机可以启动成千上百个容器；4、资源利用率高；5、更容易迁移；6、更容易维护；7、更容易扩展。

​	缺点：1. 计算能力还是逊色于宿主机

### **1.1.2 容器的三大核心**

docker是C/S架构的程序，docker客户端向docker服务器端也就是docker的守护进程发送请求，守护进程处理完所有的工作并返回结果，通过docker客户端执行各种命令，然后docker客户端会将这些命令发送给守护进程，守护进程执行的结果还会传回客户端，使我们能通过客户端来查看命令运行的结果。

- **Image(镜像)**

先了解下什么是镜像：

我们都知道，操作系统分为 内核 和 用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:20.04 就包含了完整的一套 Ubuntu 20.04 最小系统的 root 文件系统。

**Docker 镜像** 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

**分层存储**

因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。

- **Registry(仓库)**

docker用仓库来保存用户构建的镜像，仓库分私有和公有两种，docker公司提供一个公有的仓库，叫docker hub。

- **Container(容器)**

容器通过镜像启动，容器中可以运行客户的一个或多个进程。当一个容器启动时，该镜像会在最顶层加载一个读写文件系统（可写层），在docker中运行的程序，就是在这个层中进行执行的，当docker第一次启动容器时，初始的可写层是空的，当文件系统发生变化时，这些变化都会应用到这一层上。比如，如果想修改一个文件，该文件会从最下面的只读层复制到读写层，该文件的只读版本依然存在，但是被读写的文件副本所隐藏，这就是写时复制。每一个只读镜像层都是只读的，当创建一个新容器时，docker会构建一个镜像栈，在栈的最顶层添加可写层。



### **1.1.3 Docker环境准备**

更新apt包索引

```shell
apt-get update
```



安装软件包以允许apt通过HTTPS使用存储库

```shell
apt-get -y install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
```



添加Docker的官方GPG密钥

```shell
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```



安装add-apt-repository工具

```shell
apt-get -y install software-properties-common
```



添加稳定的存储库

```shell
add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
```



更新apt包索引

```shell
apt-get update
```



查看Docker版本

```shell
apt-cache madison docker-ce
```

 

安装docker-ce最新版本

```shell
apt-get -y install docker-ce docker-ce-cli containerd.io
docker info
```

解决问题：WARNING: No swap limit support(操作系统下docker不支持swap内存限制的警告),基于RPM的系统上不会发生此警告，该系统默认情况下启用这些功能。解决方法：vim /etc/default/grub  添加或编辑GRUB_CMDLINE_LINUX行以添加这两个键值对"cgroup_enable=memory swapaccount=1"，例子：

```shell
GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1 net.ifnames=0 vga=792 console=tty0 console=ttyS0,115200n8 noibrs"
```

 执行命令更新grub并重启机器

```shell
update-grub && reboot
```



docker 在 1.13 版本之后，将系统iptables 中 FORWARD 链的默认策略设置为 DROP，并为连接到 docker0 网桥的容器添加了ACCEPT规则，临时解决办法：

```shell
iptables -P FORWARD ACCEPT
```

永久解决办法：

```shell
vim /lib/systemd/system/docker.service
# 在[Service]下添加：
	ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT
systemctl daemon-reload && systemctl restart docker.service
```



设置daemon.json配置镜像加速器

```shell
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://x868aafl.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```



### **1.1.4 Containerd环境准备**

```shell
# 访问GitHub查询Containerd最新版本
https://github.com/containerd/containerd/releases/

# 下载
cd /root ; wget https://github.com/containerd/containerd/releases/download/v1.6.6/cri-containerd-1.6.6-linux-amd64.tar.gz

# 查看压缩包里的文件内容
tar -tf cri-containerd-1.6.6-linux-amd64.tar.gz
# 解压缩containerd安装包
cd /root ; tar -xvf cri-containerd-1.6.6-linux-amd64.tar.gz -C /

# 生成containerd的配置文件
mkdir /etc/containerd ; containerd config default > /etc/containerd/config.toml

# config.toml内容讲解   cat /etc/containerd/config.toml
  version =2 ：这个是新本版基本默认的选项。
  root：containerd保存元数据的地方。
  state: containerd的状态目录，重启数据就会刷新，就一个临时目录。
  address: 这个指的是containerd监听的套接字。
  plugins: 其中sandbox_image配置的是cni的插件，
  以及配置的cni的二进制目录和初始化目录；还有配置的私有库的地址，证书，访问的用户密码
  path: container的二进制文件路径
  interval:containerd重启的时间间隔
  runtime：这部分配置需要的运行时runc,containerd-shim这个垫片可以选择用或者不用

# 将sandbox_image镜像源设置为阿里云下载,文件的第61行
sed -i "s#k8s.gcr.io/pause#registry.cn-hangzhou.aliyuncs.com/google_containers/pause#g"  /etc/containerd/config.toml

# 设置阿里云镜像加速，文件的第153行
sed -i '/registry.mirrors]/a\ \ \ \ \ \ \ \ [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]' /etc/containerd/config.toml
sed -i '/registry.mirrors."docker.io"]/a\ \ \ \ \ \ \ \ \ \ endpoint = ["https://x868aafl.mirror.aliyuncs.com"]' /etc/containerd/config.toml 

# 设置containerd的Cgroup drivers为systemd,文件的第125行
sed -i 's#SystemdCgroup = false#SystemdCgroup = true#g' /etc/containerd/config.toml

# 启动containerd
systemctl enable --now containerd.service ; systemctl status containerd.service
```



## **1.2 Docker命令练习**

### **1.2.1 镜像的入门管理**

```shell
# 查看docker的信息
docker info

# 查找镜像
docker search xxxx

# 列出本机的容器镜像
docker images
          REPOSITORY：表示镜像的仓库源
          TAG：镜像的标签
          IMAGE ID：镜像ID
          CREATED：镜像创建时间
          SIZE：镜像大小
# 下载镜像到本机
docker pull nginx:1.9.6

# 删除镜像
docker rmi nginx:1.9.6

# 镜像的导出
docker save nginx:1.21 | gzip > nginx-1-21.tar.gz

# 镜像的导入
docker load -i nginx-1-21.tar.gz
```



### **1.2.2 容器的创建与管理**

```shell
# 创建前端运行的容器
docker run --name test -it nginx:1.9.6 /bin/bash


# 创建后端运行的容器
docker run --name test02 -itd nginx:1.9.6



# 创建容器练习三
docker run -d --privileged --restart=unless-stopped \
    -p 80:80 \
    -v /opt/nginx:/var/lib/nginx \
    --name nginx-demo \
    nginx:latest
    
# 参数详解
-d	后台创建并运行

--privileged 使用该参数，container内的root拥有真正的root权限。否则container内的root只是外部的一个普通用户权限

--restart=unless-stopped 		设置容器的重启策略：
        no，默认策略，在容器退出时不重启容器
        on-failure，在容器非正常退出时（退出状态非0），才会重启容器
        on-failure:3，在容器非正常退出时重启容器，最多重启3次
        always，在容器退出时总是重启容器
        unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器
        
-P	Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。

-p	指定要映射的IP和端口

-v 将宿主机的本地目录挂载到容器中的目录做数据存储

--name	制定容器运行的名称

# 查看容器
docker ps -a

# 删除容器
docker rm -f nginx-demo

# 停止、重启、启动容器
docker stop/restart/start nginx-demo

# 查看容器状态
docker stats nginx-demo

# 查看容器top信息
docker top nginx-demo

# 进入容器
docker exec -it nginx-demo /bin/bash

# 查看容器日志
docker logs nginx-demo 
```



### **1.2.3 镜像的创建**

#### **1.2.3.1 commit方式**

```shell
# 创建一个基础容器并更新容器内容
docker run --name test-nginx -it nginx:1.14.2 /bin/bash
touch /root/damon
exit

# 创建新的镜像
docker commit test-nginx demo002-nginx


```



#### **1.2.3.2 Docker file方式**

```shell
# 创建nginx-dockerfile目录，后续操作都在此目录下执行
mkdir nginx-dockerfile

# 下载nginx的安装包到本地
cd nginx-dockerfile
wget http://nginx.org/download/nginx-1.21.6.tar.gz

# 编辑nginx.config
vim nginx.conf
user	nginx;
worker_processes 1;

# 创建index.html
echo damon > index.html

# 创建空白的dockerfile文件
vim Dockerfile

# Dockerfile文件内容如下
FROM centos:centos7.7.1908

MAINTAINER Damon Meng <damon@qq.com>

RUN yum install -y  gcc gcc-c++  pcre pcre-devel zlib zlib-devel openssl openssl-devel \
    && useradd -r -s /sbin/nologin nginx \
    && yum clean all 

ADD nginx-1.21.6.tar.gz /usr/local/src/ 

RUN cd /usr/local/src/nginx-1.21.6 \
    && ./configure --prefix=/apps/nginx \
    && make \
    && make install \
    && rm -rf /usr/local/src/nginx*

ADD nginx.conf /apps/nginx/conf/nginx.conf

COPY index.html /apps/nginx/html/

RUN ln -s /apps/nginx/sbin/nginx /usr/sbin/nginx 

EXPOSE 80 443

CMD ["nginx","-g","daemon off;"]


# 创建镜像
docker build -t centos7.7-nginx:1.21.6 ./

# 查看创建的镜像
docker images
```

### **1.2.4 搭建私有化镜像仓库**

```shell
# 下载离线安装包
wget 
 
# 下载docker-compose
wget https://rancher-mirror.rancher.cn/docker-compose/v1.28.5/docker-compose-Linux-x86_64
chmod +x docker-compose-Linux-x86_64 && mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose

# 解压缩Harbor安装包
tar xvf harbor-online-installer-v2.5.0.tgz
cd harbor ; cp harbor.yml.tmpl harbor.yml

# 修改harbor.yaml文件的hostname为本机ip并且注释掉https相关字段
hostname: 172.24.52.26

# https related config
#https:
  # https port for harbor, default is 443
  #  port: 443
  # The path of cert and key files for nginx
  #certificate: /your/certificate/path
  #private_key: /your/private/key/path


# 安装harbor之前需要在harbor安装目录下修改harbor.yml 文件
./install.sh

# 在harbor目录下通过docker-compose.yml文件进行harbor服务的管理
## 启动harbor服务
 docker-compose up -d
 
## 停止harbor服务
 docker-compose down

# 登陆Harbor web创建普通用户，设定密码后登陆普通用户创建项目




--------------------------------------------------------------------------------------------------
# 修改docker daemon.json ，添加安全私有镜像仓库
vim /etc/docker/daemon.json
{
  "registry-mirrors": ["https://x868aafl.mirror.aliyuncs.com"],
  "insecure-registries": ["0.0.0.0/0"]
}
systemctl daemon-reload ; systemctl restart docker.service 

# docker login 私有仓库
docker login http://172.24.220.93/

# docker 推出仓库登陆
docker logout http://172.24.220.93/

# 上传image到bernard用户的私有仓库中
docker tag nginx:1.9.6 172.24.52.26/cka-test01/nginx:1.9.6
docker push 172.24.52.26/cka-test01/nginx:1.9.6

docker tag SOURCE_IMAGE[:TAG] 172.24.52.26/cka-test02/REPOSITORY[:TAG]
```

## **1.3 Containerd命令练习**

1.3.1 查看namespace

```shell
# 查看containerd版本
ctr version

# 查看namespace
ctr namespace list

# 创建namespace
 ctr namespace create cka
 
# 删除namespace
ctr namespace rm cka
```



### **1.3.1 镜像的入门管理**

```shell
# 列出本机的容器镜像
ctr -n k8s.io images list

# 下载镜像到本机,注意：需要填写完整的镜像仓库地址
ctr -n default images pull docker.io/library/nginx:1.9.6

# 删除镜像
ctr -n default images rm docker.io/library/nginx:1.9.6

# 导出镜像
ctr -n default images  export nginx.tar docker.io/library/nginx:1.9.6

# 导入镜像
ctr -n default images import nginx.tar
```



### **1.3.2 容器的创建与管理**

```shell
# 创建容器
ctr -n default containers create docker.io/library/nginx:1.9.6 test-nginx

# 启动容器
ctr -n default tasks start -d test-nginx

# 停止容器
 ctr -n default tasks kill test-nginx

# 查看容器
ctr -n default container list

# 删除容器
ctr -n default container rm test-nginx

# 查看容器的详细信息
ctr -n default containers info test-nginx

# 查看容器状态
ctr -n default task ls

# 获取容器的监控信息
ctr -n default task metrics test-nginx

# 删除容器
ctr -n default containers rm test-nginx
```



### **1.3.3 镜像的创建**

```shell
# 查看buildkit工具最新版本
https://github.com/moby/buildkit工具最新版本/releases

# 下载buildkit
wget https://github.com/moby/buildkit/releases/download/v0.10.3/buildkit-v0.10.3.linux-amd64.tar.gz

# 解压缩安装包
tar -xvf buildkit-v0.10.3.linux-amd64.tar.gz -C /usr/local

# 启动buildkit服务，buildkitd默认运行在前台的,如果需要运行在后端需要添加 &，使用 --oci-worker=false --containerd-worker=true参数,可以让buildkitd服务使用containerd后端
buildkitd --oci-worker=false --containerd-worker=true & 

# 构建本地镜像
buildctl build \
    --frontend=dockerfile.v0 \
    --local context=. \
    --local dockerfile=. \
    --output type=image,name=docker.io/username/image:tag
    
rontend可以使用网关做前端,未做其他尝试,这里直接使用dockerfile.0
--local context 指向当前目录,这是Dockerfile执行构建时的路径上下文,比如在从目录中拷贝文件到镜像里
--local dockerfile指向当前目录,表示Dockerfile在此目录
--output 的 name 表示构建的镜像名称
构建完成后镜像会存在本地containerd的buildkit名字空间下

# 推送镜像
ctr -n buildkit i push -u username:password docker.io/username/image:tag

# 构建镜像并推送镜像
buildctl build \
    --frontend=dockerfile.v0 \
    --local context=. \
    --local dockerfile=. \
    --output type=image,name=docker.io/username/image:tag,push=true
```



